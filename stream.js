/** * Created by hoss on 4/9/2017. */let streamedValues = [];function asyncSort(data) {  // Return a promise  return new Promise(function(resolve) {    //  web worker:    function onmessage(e) {      e.data.sort((a, b) => a - b);      postMessage(e.data);    }    //  passing  (as blob URL)    var worker = new Worker(URL.createObjectURL(        new Blob(['onmessage = ' + onmessage.toString()])));    // Capture on finished    worker.onmessage = function(e) {      resolve(e.data); // resolve    };    //  worker execute sort (async)    worker.postMessage(data);  });}  const PI_URL = 'http://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt';  const progressText = [];  const progress = [];  const encoder = new TextEncoder();  let bytesValue = new Uint8Array();  bytesValue = encoder.encode(123456);  const bytesAsStrings = Array.prototype.map.call(bytesValue,      b => `0x${b.toString(16)}`);  let soFar;  let contentLength;  fetch(`https://cors-anywhere.herokuapp.com/${PI_URL}`).then(res => {    soFar = 0;    contentLength = res.headers.get('Content-Length');    progress.max = contentLength;// lenth is a billion and 2    return pump(res.body.getReader());  }).catch(e => console.log(e));  const pump = reader => {    //reader.read//promise object iwth Uint8Array(32768)    return reader.read().then(result => {      if (result.done) {        progressText.textContent = `All done! (${soFar} bytes total)`;      }      const chunk = result.value;      soFar += chunk.byteLength;      updateProgress();      let found = -1;      for (let i = 0; i < chunk.length; ++i) {        streamedValues.push(chunk[i]);        if (chunk[i] === bytesValue[0]) {          found = i;          for (let j = 1; j < bytesValue.length; ++j) {            if (chunk[i + j] !== bytesValue[j]) {              found = -1;              break;            }          }        }        if (found !== -1) {          break;        }      }      if (found !== -1) {        progressText.textContent = `Found it! At position ${soFar -        chunk.byteLength + found}.`;        console.log(progressText.textContent);        return reader.cancel();      }      else {        asyncSort(streamedValues).then(function(result) {        //map results to object to flatten repeaters          console.log('sorted values', result);          console.log('package hit');          return pump(reader);        });      }    });  };  const updateProgress = () => {    progressText.textContent = contentLength        ? `${soFar}/${contentLength} bytes received`        : `${soFar} bytes received`;    progress.value = contentLength ? soFar : null;    console.log('progress content', progressText.textContent);    console.log('progress.value', progress.value);  };